"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.allPathsAreValid = void 0;
var util_functions_1 = require("../core/util/util-functions");
var state_manager_1 = require("../core/convo-engine/state-manager");
var Either_1 = require("fp-ts/lib/Either");
var logging_1 = __importDefault(require("../core/util/logging"));
var Option_1 = require("fp-ts/lib/Option");
var allNestedModules = function (rootModule) {
    var visitedPathsAndModules = new Set();
    var modulesToVisit = [
        { path: [rootModule.id], module: rootModule },
    ];
    var _loop_1 = function () {
        var currentPathAndModule = modulesToVisit.pop();
        if (currentPathAndModule === undefined) {
            throw new Error("Unreachable null-check error in path validity test. This indicates a problem with the test");
        }
        visitedPathsAndModules.add(currentPathAndModule);
        var currentPath = currentPathAndModule.path, currentModule = currentPathAndModule.module;
        Object.values(currentModule.submodules).forEach(function (submodule) {
            var newPath = __spreadArrays(currentPath, [submodule.id]);
            modulesToVisit.push({
                path: newPath,
                module: submodule,
            });
        });
    };
    while (modulesToVisit.length > 0) {
        _loop_1();
    }
    return visitedPathsAndModules;
};
var pathFromActon = function (action) {
    switch (action.type) {
        case 'start-convo-segment':
            return [action.path];
        default:
            return [];
    }
};
var allPathsFromActions = function (actions) {
    return actions.map(pathFromActon).reduce(util_functions_1.concatArraysReducer, []);
};
var allPathsFromChoice = function (choice) {
    return choice.logic
        .map(function (logic) {
        // De-duplication here, because the `otherwise` case is auto generated by the logic constructor if no `if` statement is specified
        if (logic._compiledWithoutConditional) {
            return __spreadArrays(allPathsFromActions(logic.do));
        }
        else {
            return __spreadArrays(allPathsFromActions(logic.do), allPathsFromActions(logic.otherwise));
        }
    })
        .reduce(util_functions_1.concatArraysReducer, []);
};
var allPathsFromChoices = function (choices) {
    return choices.map(allPathsFromChoice).reduce(util_functions_1.concatArraysReducer, []);
};
var convoSegmentPathConstructor = function (parentModules, id) { return ({
    parentModules: parentModules,
    id: id,
}); };
// Does not consider nested paths
var allPathsFromModule = function (pathAndModule) {
    return Object.values(pathAndModule.module.convoSegments)
        .map(function (convoSegment) {
        var pathValues = allPathsFromChoices(convoSegment.choices);
        return pathValues.map(function (pathValue) { return ({
            pathValue: pathValue,
            pathInstantiation: convoSegmentPathConstructor(pathAndModule.path, convoSegment.id),
        }); });
    })
        .reduce(util_functions_1.concatArraysReducer, []);
};
var allPathsFromModuleAndItsSubmodules = function (rootModule) {
    var allModules = allNestedModules(rootModule);
    return Array.from(allModules)
        .map(allPathsFromModule)
        .reduce(util_functions_1.concatArraysReducer, []);
};
var pathIsValid = function (root, currentPath, testPath) {
    return Either_1.fold(function (error) { return false; }, function (value) { return true; })(state_manager_1.safelyGetConvoSegment(root, testPath, currentPath));
};
var pathLookupResultFromPathAndInstantiation = function (rootModule) { return function (pathAndInstatiation) { return (__assign(__assign({}, pathAndInstatiation), { pathIsValid: pathIsValid(rootModule, pathAndInstatiation.pathInstantiation, pathAndInstatiation.pathValue) })); }; };
exports.allPathsAreValid = function (config) {
    logging_1.default.debug("~~~~~> Checking that all module paths are valid");
    var flatmapPathsAndConvoSegmentInstantiations = allPathsFromModuleAndItsSubmodules(config.rootModule);
    var pathLookupCurried = pathLookupResultFromPathAndInstantiation(config.rootModule);
    var lookupResults = flatmapPathsAndConvoSegmentInstantiations.map(pathLookupCurried);
    var invalidPaths = lookupResults.filter(function (lookupResult) { return !lookupResult.pathIsValid; });
    var delimeter = "=======";
    if (invalidPaths.length > 0) {
        logging_1.default.error("The following paths are invalid!");
        invalidPaths.forEach(function (invalidPath) {
            logging_1.default.error(delimeter, "invalid path ", invalidPath.pathValue);
            logging_1.default.debug("For reference, this path is defined in the convo segment", invalidPath.pathInstantiation);
        });
        return Option_1.some(Error("Invalid path in module definition! Please fix this before running the chatbot server."));
    }
    else {
        logging_1.default.debug("~~~~~> All paths are valid!");
        return Option_1.none;
    }
};
//# sourceMappingURL=path-validity.js.map